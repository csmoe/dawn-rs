use heck::{ToPascalCase, ToSnakeCase};

use crate::{
    Annotation, BitmaskDef, DawnApi, FunctionDef, MethodDef, ObjectDef, RecordMember, ReturnType,
    StructureDef,
};

pub trait Codegen {
    fn codegen(&self) -> String;
}

impl DawnApi {
    pub fn codegen(self) -> String {
        let objects = self
            .objects()
            .iter()
            .map(|(name, def)| Object { name, def }.codegen())
            .collect::<Vec<_>>()
            .join("\n");
        let functions = self
            .functions()
            .iter()
            .map(|(name, def)| Function { name, def }.codegen())
            .collect::<Vec<_>>()
            .join("\n");
        let structs = self
            .structures()
            .iter()
            .map(|(name, def)| Structure { name, def }.codegen())
            .collect::<Vec<_>>()
            .join("\n");
        let DawnApi { comment, doc, .. } = self;
        let comment = comment
            .unwrap_or_default()
            .iter()
            .map(|c| format!("/// {c}"))
            .collect::<Vec<_>>()
            .join("\n");
        let doc = doc
            .as_ref()
            .map(|d| format!("/// {}", d))
            .unwrap_or_default();
        let version = env!("CARGO_PKG_VERSION");

        let source = syn::parse_file(&format!(
            r#"
{comment}
{doc}

/// Generated by dawn-codegen {version}

{structs}

{objects}

{functions}
"#
        ))
        .unwrap();
        prettyplease::unparse(&source)
    }
}

struct Function<'a> {
    name: &'a str,
    def: &'a FunctionDef,
}

impl Codegen for Function<'_> {
    fn codegen(&self) -> String {
        let FunctionDef {
            returns,
            args,
            comment,
            ..
        } = self.def;
        let name = self.name.to_snake_case();
        let ret = returns.codegen();
        let comment = comment
            .as_ref()
            .map(|c| format!("/// {}", c))
            .unwrap_or_default();
        let args = args
            .iter()
            .map(|arg| arg.codegen())
            .collect::<Vec<_>>()
            .join("");

        format!(
            r#"
{comment}
pub fn {name}({args}) -> {ret} {{
}}
"#
        )
    }
}

impl Codegen for Option<ReturnType> {
    fn codegen(&self) -> String {
        match self {
            Some(ReturnType::Complex {
                return_type,
                optional,
            }) => {
                let ty = return_type.to_pascal_case();
                if *optional {
                    format!("Option<{ty}>")
                } else {
                    format!("{ty}")
                }
            }
            Some(ReturnType::Simple(return_type)) => {
                let ty = return_type.to_pascal_case();
                format!("{ty}")
            }
            None => "()".to_string(),
        }
    }
}

impl Codegen for RecordMember {
    fn codegen(&self) -> String {
        let RecordMember {
            name,
            member_type,
            annotation,
            length,
            optional,
            default,
            wire_is_data_only,
            skip_serialize,
            no_default,
            array_element_optional,
        } = &self;
        let name = if name.to_lowercase() == "type" {
            "r#type".to_string()
        } else {
            name.to_snake_case()
        };
        let ty = member_type.to_pascal_case();
        let annotation = annotation.codegen();

        format!("{name}: {annotation} {ty},")
    }
}

impl Codegen for Annotation {
    fn codegen(&self) -> String {
        match self {
            Annotation::MutPtr => "*mut ",
            Annotation::ConstPtr => "*const ",
            Annotation::ConstConstPtr => "*const *const ",
            Annotation::Value => "",
        }
        .to_string()
    }
}

struct Method<'a> {
    self_: &'a Object<'a>,
    def: &'a MethodDef,
}

impl Codegen for Method<'_> {
    fn codegen(&self) -> String {
        let MethodDef {
            name,
            tags,
            returns,
            args,
            no_autolock,
            extensible,
        } = &self.def;
        let name = name.to_snake_case();
        let ret = returns.codegen();
        let args_types = args
            .iter()
            .map(|arg| arg.codegen())
            .collect::<Vec<String>>()
            .join("");
        let safety = if no_autolock.unwrap_or_default() {
            r#"/// <div class="warning">
/// This method is not thread-safe
/// </div>"#
        } else {
            ""
        };

        let object_name = self.self_.name.to_pascal_case();
        let c_name = name.to_pascal_case();
        let args_names = args
            .iter()
            .map(|arg| {
                let name = arg.name.to_snake_case();
                if name == "type" {
                    "r#type".into()
                } else {
                    name
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        format!(
            r#"{safety}
pub fn {name}(&self, {args_types}) -> {ret} {{
    unsafe {{
        wgpu{object_name}{c_name}(std::ptr::from_ref(self), {args_names})
    }}
}}"#
        )
    }
}

struct Object<'a> {
    name: &'a str,
    def: &'a ObjectDef,
}

impl Codegen for Object<'_> {
    fn codegen(&self) -> String {
        let ObjectDef {
            tags,
            methods,
            no_autolock,
        } = &self.def;
        let name = self.name.to_pascal_case();
        let methods = methods
            .iter()
            .map(|method| {
                Method {
                    self_: self,
                    def: method,
                }
                .codegen()
            })
            .collect::<Vec<String>>()
            .join("\n");
        let thread_safety = if no_autolock.unwrap_or_default() {
            format!("unsafe impl !Send for {name} {{}}\nunsafe impl !Sync for {name} {{}}")
        } else {
            format!("unsafe impl Send for {name} {{}}\nunsafe impl Sync for {name} {{}}")
        };
        format!(
            r#"
pub struct {name};

impl Clone for {name} {{
    fn clone(&self) -> Self {{
        unsafe {{
            wgpu{name}AddRef(std::ptr::from_ref(self))
        }}
    }}
}}

impl Drop for {name} {{
    fn drop(&mut self) {{
        unsafe {{
            wgpu{name}Release(std::ptr::from_ref(self))
        }}
    }}
}}

{thread_safety}

impl {name} {{
    {methods}
}}"#
        )
    }
}

struct Structure<'a> {
    name: &'a str,
    def: &'a StructureDef,
}

impl Codegen for Structure<'_> {
    fn codegen(&self) -> String {
        let StructureDef {
            tags,
            members,
            comment,
            ..
        } = &self.def;
        let name = self.name.to_pascal_case();
        let fields = members
            .iter()
            .map(|field| field.codegen())
            .collect::<Vec<String>>()
            .join("\n");
        let comment = comment
            .as_ref()
            .map(|comment| format!("/// {}", comment))
            .unwrap_or_default();
        format!(
            r#"
{comment}
pub struct {name} {{
    {fields}
}}"#
        )
    }
}

/*
struct Bitmask<'a> {
    name: &'a str,
    def: &'a BitmaskDef,
}

impl Codegen for Bitmask<'_> {
    fn codegen(&self) -> String {
        let BitmaskDef { tags, values, .. } = &self.def;
        let name = self.name.to_pascal_case();
        let fields = members
            .iter()
            .map(|field| field.codegen())
            .collect::<Vec<String>>()
            .join("\n");
        let comment = comment
            .as_ref()
            .map(|comment| format!("/// {}", comment))
            .unwrap_or_default();
        format!(
            r#"
{comment}
pub struct {name} {{
    {fields}
}}"#
        )
    }
}

*/
