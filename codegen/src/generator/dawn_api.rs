use std::collections::{HashMap, HashSet};

use heck::{ToPascalCase, ToSnakeCase};

use crate::{
    Annotation, BitmaskDef, DawnApi, EnumDef, EnumValueDef, ExtensibleType, Extension, FunctionDef,
    MethodDef, ObjectDef, RecordMember, ReturnType, StructureDef,
};

pub trait Codegen {
    fn codegen(&self) -> String;
}

impl DawnApi {
    pub fn codegen(self) -> String {
        let objects = self
            .objects()
            .iter()
            .map(|(name, def)| {
                Object {
                    api: &self,
                    name,
                    def,
                }
                .codegen()
            })
            .collect::<Vec<_>>()
            .join("\n");
        let functions = self
            .functions()
            .iter()
            .map(|(name, def)| {
                Function {
                    api: &self,
                    name,
                    def,
                }
                .codegen()
            })
            .collect::<Vec<_>>()
            .join("\n");
        let structs = self
            .structures()
            .iter()
            .map(|(name, def)| {
                Structure {
                    name,
                    def,
                    extensions: &self.extensions(),
                }
                .codegen()
            })
            .collect::<Vec<_>>()
            .join("\n");
        let bitmasks = self
            .bitmasks()
            .iter()
            .map(|(name, def)| Bitmask { name, def }.codegen())
            .collect::<Vec<_>>()
            .join("\n");
        let enums = self
            .enums()
            .iter()
            .map(|(name, def)| Enum { name, def }.codegen())
            .collect::<Vec<_>>()
            .join("\n");
        let extensions = codegen_extensions(&self.extensions());
        let DawnApi { comment, doc, .. } = self;
        let comment = comment
            .unwrap_or_default()
            .iter()
            .map(|c| format!("/// {c}"))
            .collect::<Vec<_>>()
            .join("\n");
        let doc = doc
            .as_ref()
            .map(|d| format!("/// {}", d))
            .unwrap_or_default();
        let version = env!("CARGO_PKG_VERSION");

        let content = format!(
            r#"{comment}
{doc}

/// Generated by dawn-codegen {version}

{bitmasks}

{enums}

{structs}

{objects}

{functions}

{extensions}
"#
        );
        //content

        let source = syn::parse_file(&content).unwrap();
        prettyplease::unparse(&source)
    }
}

struct Function<'a> {
    api: &'a DawnApi,
    name: &'a str,
    def: &'a FunctionDef,
}

impl Codegen for Function<'_> {
    fn codegen(&self) -> String {
        let FunctionDef {
            returns,
            args,
            tags,
            comment,
            ..
        } = self.def;
        let name = self.name.to_snake_case();
        let ret_is_unsafe = self.api.objects().iter().any(|(name, obj)| {
            returns
                .as_ref()
                .filter(|r| r.get_type() == name.as_str())
                .is_some()
                && obj.no_autolock.unwrap_or_default()
        });
        let ret = returns.codegen();
        let comment = comment
            .as_ref()
            .map(|c| format!("/// {}", c))
            .unwrap_or_default();
        let args_tys = args
            .iter()
            .map(|arg| {
                let (_, tys, _) = arg.codegen();
                tys
            })
            .collect::<Vec<_>>()
            .join(",");
        let args_names = args
            .iter()
            .map(|arg| {
                let (name, _, _) = arg.codegen();
                name
            })
            .collect::<Vec<_>>()
            .join(", ");

        let wrap = if ret_is_unsafe {
            format!("{ret}(inner, std::marker::PhantomData)")
        } else if let Some(returns) = returns {
            if returns.is_optional() {
                format!("Some({}(inner))", returns.get_type().to_pascal_case())
            } else {
                format!("{}(inner)", returns.get_type().to_pascal_case())
            }
        } else {
            "".into()
        };
        let features = codegen_features(tags);
        format!(
            r#"
{comment}
{features}
pub fn {name}({args_tys}) -> {ret} {{
    let inner = unsafe {{
        sys::wgpu{name}({args_names})
    }};
    {wrap}
}}
"#
        )
    }
}

impl Codegen for Option<ReturnType> {
    fn codegen(&self) -> String {
        match self {
            Some(ReturnType::Complex {
                return_type,
                optional,
            }) => {
                let ty = return_type.to_pascal_case();
                if *optional {
                    format!("Option<{ty}>")
                } else {
                    format!("{ty}")
                }
            }
            Some(ReturnType::Simple(return_type)) => {
                let ty = return_type.to_pascal_case();
                format!("{ty}")
            }
            None => "()".to_string(),
        }
    }
}

impl RecordMember {
    fn codegen(&self) -> (String, String, String) {
        let RecordMember {
            name,
            member_type,
            annotation,
            length,
            optional,
            default,
            wire_is_data_only,
            skip_serialize,
            no_default,
            array_element_optional,
        } = &self;
        let arg_name = if name.to_lowercase() == "type" {
            "r#type".to_string()
        } else {
            name.to_snake_case()
        };

        let mut arg_ty = match member_type.as_str() {
            "long" => "i64".to_string(),
            "uint16_t" => "u16".to_string(),
            "int16_t" => "i16".to_string(),
            "uint32_t" | "uint" => "u32".to_string(),
            "int32_t" | "int" => "i32".to_string(),
            "uint64_t" => "u64".to_string(),
            "int64_t" => "i64".to_string(),
            "bool" => "bool".to_string(),
            "float" => "f32".to_string(),
            "double" => "f64".to_string(),
            "size_t" => "usize".to_string(),
            "string view" => "String".to_string(),
            _ => member_type.to_pascal_case(),
        };

        if *optional {
            arg_ty = format!("Option<{arg_ty}>");
        }
        let mut default_code = "".to_string();
        let mut arg_stmt = "".to_string();
        if !annotation.is_value() {
            if no_default.unwrap_or_default() {
                arg_ty = if annotation.is_const_ptr() {
                    format!("&{arg_ty}")
                } else {
                    format!("&mut {arg_ty}")
                }
                .to_string();
            } else {
                default_code = {
                    let default = match default {
                        Some(v) => v.to_string(),
                        None => {
                            if annotation.is_const_ptr() {
                                format!("std::ptr::null()")
                            } else {
                                format!("std::ptr::null_mut()")
                            }
                        }
                    };
                    format!(".unwrap_or_else(|| {default})")
                }
            };
            arg_stmt = format!("let {arg_name} = {arg_name}{default_code};");
        }
        //let annotation = annotation.codegen();

        let arg = format!("{arg_name}: {arg_ty},");
        (arg_name + ",", arg, arg_stmt)
    }
}

impl Codegen for Annotation {
    fn codegen(&self) -> String {
        match self {
            Annotation::MutPtr => "*mut ",
            Annotation::ConstPtr => "*const ",
            Annotation::ConstConstPtr => "*const *const ",
            Annotation::Value => "",
        }
        .to_string()
    }
}

struct Method<'a> {
    self_: &'a Object<'a>,
    api: &'a DawnApi,
    def: &'a MethodDef,
}

impl Codegen for Method<'_> {
    fn codegen(&self) -> String {
        let MethodDef {
            name,
            tags,
            returns,
            args,
            no_autolock,
            extensible,
        } = &self.def;
        let name = name.to_snake_case();

        let ret_is_unsafe = self.api.objects().iter().any(|(name, obj)| {
            returns
                .as_ref()
                .filter(|r| r.get_type() == name.as_str())
                .is_some()
                && obj.no_autolock.unwrap_or_default()
        });
        let ret = returns.codegen();

        let safety = if no_autolock.unwrap_or_default() {
            r#"/// <div class="warning">
/// This method is not thread-safe
/// </div>"#
        } else {
            ""
        };

        let object_name = self.self_.name.to_pascal_case();
        let c_name = name.to_pascal_case();
        let args_names = args
            .iter()
            .map(|arg| {
                let (name, ..) = arg.codegen();
                name
            })
            .collect::<Vec<_>>()
            .join("");
        let args_types = args
            .iter()
            .map(|arg| {
                let (_, tys, _) = arg.codegen();
                tys
            })
            .collect::<Vec<String>>()
            .join("");
        let args_stms = args
            .iter()
            .map(|arg| {
                let (_, _, stmt) = arg.codegen();
                stmt
            })
            .collect::<Vec<String>>()
            .join("");

        let wrap = if ret_is_unsafe {
            format!("{ret}(inner, std::marker::PhantomData)")
        } else if let Some(returns) = returns {
            if returns.is_optional() {
                format!("Some({}(inner))", returns.get_type().to_pascal_case())
            } else {
                format!("{}(inner)", returns.get_type().to_pascal_case())
            }
        } else {
            "".into()
        };
        let features = codegen_features(tags);
        format!(
            r#"{safety}
{features}
pub fn {name}(&mut self, {args_types}) -> {ret} {{
{args_stms}
    let inner = unsafe {{
        sys::wgpu{object_name}{c_name}(std::ptr::from_mut(self).cast(), {args_names})
    }};
    {wrap}
}}"#
        )
    }
}

struct Object<'a> {
    name: &'a str,
    api: &'a DawnApi,
    def: &'a ObjectDef,
}

impl Codegen for Object<'_> {
    fn codegen(&self) -> String {
        let ObjectDef {
            tags,
            methods,
            no_autolock,
        } = &self.def;
        let name = self.name.to_pascal_case();
        let methods = methods
            .iter()
            .map(|method| {
                Method {
                    api: self.api,
                    self_: self,
                    def: method,
                }
                .codegen()
            })
            .collect::<Vec<String>>()
            .join("\n");
        let features = codegen_features(tags);
        let (unsafe_marker, safe, marker_init) = if no_autolock.unwrap_or_default() {
            (
                format!("std::marker::PhantomData<*const ()>"),
                "".into(),
                "std::marker::PhantomData".to_string(),
            )
        } else {
            (
                "".into(),
                format!(
                    r#"{features} unsafe impl Send for {name} {{}}
                    {features} unsafe impl Sync for {name} {{}}"#
                ),
                "".into(),
            )
        };
        format!(
            r#"
#[repr(transparent)]
{features}
pub struct {name}(
    sys::WGPU{name},
    {unsafe_marker}
);

{safe}

{features}
impl Clone for {name} {{
    fn clone(&self) -> Self {{
        unsafe {{
            sys::wgpu{name}AddRef(std::ptr::from_ref(self).cast_mut().cast());
            Self(self.0, {marker_init})
        }}
    }}
}}

{features}
impl Drop for {name} {{
    fn drop(&mut self) {{
        unsafe {{
            sys::wgpu{name}Release(std::ptr::from_mut(self).cast())
        }}
    }}
}}


{features}
impl {name} {{
    {methods}
}}"#
        )
    }
}

struct Structure<'a> {
    name: &'a str,
    def: &'a StructureDef,
    extensions: &'a HashMap<&'a String, HashSet<Extension<'a>>>,
}

impl Codegen for Structure<'_> {
    fn codegen(&self) -> String {
        let StructureDef {
            tags,
            members,
            comment,
            extensible,
            ..
        } = &self.def;
        let name = self.name.to_pascal_case();
        let fields = members
            .iter()
            .map(|field| {
                let (_, tys, _) = field.codegen();
                tys
            })
            .collect::<Vec<String>>()
            .join("");
        let comment = comment
            .as_ref()
            .map(|comment| format!("/// {}", comment))
            .unwrap_or_default();
        let features = codegen_features(tags);
        let (ext_field, extensible) = if !(extensible.extensible()
            && self
                .extensions
                .get(&self.name.to_string())
                .map(|s| !s.is_empty())
                .unwrap_or_default())
        {
            ("".into(), "".into())
        } else {
            (
                format!("extension: Option<{name}Extension>,"),
                format!(
                    r#"
{features}
impl {name} {{
    fn extend(&mut self, extension: {name}Extension) {{
        self.extension = Some(extension);
    }}
}}

"#
                ),
            )
        };
        format!(
            r#"
{comment}
{features}
pub struct {name} {{
    {ext_field}
    {fields}
}}

{extensible}
"#
        )
    }
}

struct Bitmask<'a> {
    name: &'a str,
    def: &'a BitmaskDef,
}

impl Codegen for Bitmask<'_> {
    fn codegen(&self) -> String {
        let BitmaskDef { tags, values, .. } = &self.def;
        let name = self.name.to_pascal_case();
        let variants = values
            .iter()
            .map(|value| {
                let EnumValueDef {
                    name, value, tags, ..
                } = value;
                let features = codegen_features(tags);
                format!(
                    "{features} {} = {},",
                    name.to_pascal_case(),
                    if let Some(n) = value.as_number() {
                        format_enum_value(n.as_u64().unwrap() as _, tags)
                    } else {
                        value.to_string()
                    }
                )
            })
            .collect::<Vec<String>>()
            .join("\n");

        let features = codegen_features(tags);
        format!(
            r#"
{features}
pub enum {name} {{
    {variants}
}}"#
        )
    }
}

struct Enum<'a> {
    name: &'a str,
    def: &'a EnumDef,
}

impl Codegen for Enum<'_> {
    fn codegen(&self) -> String {
        let EnumDef { tags, values, .. } = &self.def;
        let name = self.name.to_pascal_case();
        let variants = values
            .iter()
            .map(|value| {
                let EnumValueDef {
                    name, value, tags, ..
                } = value;

                fn swap_first_two(s: &str) -> String {
                    let mut chars: Vec<char> = s.chars().collect();

                    if chars.len() >= 2 && chars[0].is_numeric() {
                        chars.swap(0, 1);
                    }

                    chars.into_iter().collect()
                }
                let features = codegen_features(tags);
                format!(
                    "{features} {} = {},",
                    swap_first_two(&name).to_pascal_case(),
                    if let Some(n) = value.as_number() {
                        format_enum_value(n.as_u64().unwrap() as _, tags)
                    } else {
                        value.to_string()
                    }
                )
            })
            .collect::<Vec<String>>()
            .join("\n");

        let features = codegen_features(tags);
        format!(
            r#"
{features}
pub enum {name} {{
    {variants}
}}"#
        )
    }
}

fn codegen_extensions(extensions: &HashMap<&String, HashSet<Extension<'_>>>) -> String {
    let mut ret = String::new();
    for (name, members) in extensions {
        let name = name.to_pascal_case();
        let variants = members
            .iter()
            .map(|ext| {
                let features = codegen_features(ext.tags);
                let member = ext.ty.to_pascal_case();
                format!("{features} {member}({member}),")
            })
            .collect::<Vec<String>>()
            .join("");
        let s_types = members
            .iter()
            .map(|ext| {
                let features = codegen_features(ext.tags);
                let member = ext.ty.to_pascal_case();
                format!("{features} Self::{member}(_) => SType::{member},")
            })
            .collect::<Vec<String>>()
            .join("");
        let from = members
            .iter()
            .map(|ext| {
                let member = ext.ty.to_pascal_case();
                let features = codegen_features(ext.tags);
                format!(
                    r#"{features}
impl std::convert::From<{member}> for {name}Extension {{
    fn from(value: {member}) -> Self {{
        Self::{member}(value)
    }}
}}"#
                )
            })
            .collect::<Vec<String>>()
            .join("");
        ret.push_str(&format!(
            r#"
#[non_exhaustive]
pub enum {name}Extension {{
    {variants}
}}

impl {name}Extension {{
    #[allow(unreachable_patterns)]
    pub fn s_type(&self) -> SType {{
        match self {{
          {s_types}
          _ => unreachable!()
        }}
    }}
}}

{from}
"#
        ));
    }
    ret
}

fn codegen_features(tags: &Vec<String>) -> String {
    let features = tags
        .iter()
        .map(|t| format!(r#"feature = "{t}""#))
        .collect::<Vec<String>>()
        .join(", ");
    if tags.is_empty() {
        return "".into();
    }
    if tags.len() == 1 {
        return format!("#[cfg({features})]");
    }
    format!(r#"#[cfg(all({features}))]"#)
}

fn apply_tags(tags: &Vec<String>) -> u32 {
    let has_dawn = tags.iter().any(|t| t.as_str() == "dawn");
    let has_emscripten = tags.iter().any(|t| t.as_str() == "emscripten");
    let has_compat = tags.iter().any(|t| t.as_str() == "compat");
    let has_native = tags.iter().any(|t| t.as_str() == "native");

    let has_value_impacting = has_dawn || has_emscripten || has_compat;

    if has_dawn {
        0x0005_0000
    } else if has_emscripten {
        0x0004_0000
    } else if has_compat {
        0x0002_0000
    } else if has_native && !has_value_impacting {
        0x0001_0000
    } else {
        0
    }
}

fn compute_enum_value(base_value: u32, tags: &Vec<String>) -> u32 {
    let prefix = apply_tags(tags);
    prefix + base_value
}

fn format_enum_value(base_value: u32, tags: &Vec<String>) -> String {
    format!("0x{:08X}", compute_enum_value(base_value, tags))
}
